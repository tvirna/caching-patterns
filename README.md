# 12 поширених патернів кешування

### Вступ

Кешування є важливим інструментом для оптимізації роботи з даними в сучасних інформаційних системах. Завдяки кешуванню можна значно зменшити навантаження на бази даних і знизити час відповіді на запити користувачів, що є критичним фактором для забезпечення високої продуктивності додатків та веб-сайтів. Однак правильний вибір стратегії кешування залежить від багатьох факторів, таких як тип даних, частота доступу до них, вимоги до актуальності інформації та специфіка навантаження на систему.

У цій доповіді розглядаються 12 основних патернів кешування, які є найбільш поширеними у практиці розробки програмного забезпечення та роботи з базами даних. Кожен з цих патернів має свої особливості та може бути використаний для досягнення різних цілей — від зниження навантаження на сервери до забезпечення актуальності даних у системах з високим навантаженням. Важливо розуміти, який саме патерн краще підходить для конкретної ситуації, щоб ефективно використовувати кешування для досягнення бажаних результатів.

Ця доповідь надасть огляд кожного з цих патернів, їх переваги та недоліки, а також практичні приклади застосування, що дозволить краще зрозуміти, як кешування може бути інтегроване в сучасні системи для оптимізації роботи з даними.

## 1. Cache Aside (Lazy Loading)

Патерн ***Cache Aside (або Lazy Loading)*** передбачає, що кешування здійснюється на стороні додатка. У цьому випадку кеш не заповнюється автоматично, а дані завантажуються в кеш тільки в момент першого запиту. Коли додаток запитує дані, він спочатку перевіряє, чи є вони в кеші. Якщо дані знайдені, вони повертаються з кешу, що значно прискорює процес доступу. Якщо ж дані відсутні в кеші, додаток звертається до бази даних, отримує потрібну інформацію, записує її в кеш для подальших запитів і повертає результат користувачу.

Цей підхід є "ледачим", тому що дані не завантажуються в кеш до тих пір, поки в них не виникне реальна потреба, що дозволяє економити ресурси, завантажуючи кеш лише актуальними даними.

### Приклади застосування

+ Пошукові системи: у пошукових системах кешування результатів запитів може використовувати патерн Cache Aside. Коли користувач запитує якусь інформацію, система перевіряє, чи є результат цього запиту в кеші. Якщо результат є, він негайно віддається з кешу. Якщо результату немає, пошукова система звертається до бази даних або виконує запит на індексовані сторінки і зберігає отриману відповідь у кеші для подальших запитів.
+ Електронна комерція: у магазинах, що продають товари, кешування даних товарів (наприклад, ціни, наявність на складі) може використовувати цей патерн. Коли клієнт запитує інформацію про продукт, система перевіряє, чи є ці дані в кеші. Якщо вони відсутні, система запитує базу даних і додає дані в кеш.
+ Соціальні мережі: в соціальних мережах кешування профілів користувачів або постів може використовувати цей патерн. Коли інший користувач хоче побачити профіль, система перевіряє наявність цього профілю в кеші. Якщо дані є, вони віддаються з кешу, інакше вони завантажуються з основної бази даних.

<ins>Розглянемо приклад використання патерну Cache Aside на прикладі мови програмування C# з кешем Redis для зберігання даних про користувача.<ins/>
```csharp
using StackExchange.Redis;
using System;

public class UserService
{
    private IDatabase _cache;
    private IDatabase _database;

    public UserService()
    {
        // Підключення до Redis
        var connection = ConnectionMultiplexer.Connect("localhost");
        _cache = connection.GetDatabase();
        _database = connection.GetDatabase();
    }

    public string GetUserProfile(int userId)
    {
        // Перевірка кешу
        string cachedProfile = _cache.StringGet($"user:{userId}");
        if (cachedProfile != null)
        {
            Console.WriteLine("Data retrieved from cache.");
            return cachedProfile;
        }

        // Якщо в кеші немає даних, завантажуємо з бази даних
        string profileFromDb = _database.StringGet($"user:{userId}");
        if (profileFromDb != null)
        {
            // Збереження результату в кеш
            _cache.StringSet($"user:{userId}", profileFromDb, TimeSpan.FromMinutes(30));
            Console.WriteLine("Data retrieved from database and cached.");
            return profileFromDb;
        }

        return "User not found";
    }
}
```
У цьому коді ми перевіряємо кеш (Redis) для наявності профілю користувача за ID. Якщо дані не знайдені, вони завантажуються з основної бази даних і кешуються для майбутніх запитів.

### Переваги:

+ Економія ресурсів: кеш завантажується тільки при потребі, що дозволяє уникнути непотрібного заповнення кешу.
+ Покращення продуктивності: перші запити можуть бути більш повільними (через завантаження з бази даних), але наступні запити будуть оброблятися набагато швидше завдяки кешуванню.
+ Мінімізація навантаження на базу даних: оскільки кеш не зберігає всі дані, а тільки ті, до яких часто звертаються, це дозволяє зменшити навантаження на базу даних.

### Недоліки:

+ Тенденція до "холодного кешу": якщо система не часто звертається до певних даних, вони можуть бути відсутні в кеші, що спричинить звернення до бази даних навіть для часто запитуваних даних.
+ Неактуальні дані: якщо дані в кеші старі або не були оновлені, це може призвести до надання застарілої інформації. Для цього потрібно розробити стратегію оновлення кешу або очищення за певний час.
+ Необхідність реалізації додаткової логіки: для ефективного використання кешування може знадобитись додатковий код для управління кешем, що збільшує складність системи.

Загалом, патерн Cache Aside підходить для ситуацій, де не завжди є потреба в кешуванні всіх даних, а лише тих, що найчастіше запитуються, що дозволяє забезпечити ефективність і знижене навантаження на сервери та бази даних.

## 2. Write Through

Патерн ***Write Through*** передбачає, що кожен запис у кеш здійснюється одночасно і в основну базу даних. Кожного разу, коли додаток записує нові або оновлені дані, ці зміни відразу відображаються не лише в кеші, але й у базі даних. Це забезпечує постійну синхронізацію між кешем та основним сховищем даних.

Основна ідея цього підходу полягає в тому, що дані зберігаються в кеші так само, як і в базі даних. Такий підхід дозволяє забезпечити актуальність даних, оскільки кожна зміна відображається у обох місцях одночасно.

### Приклади застосування

+ Системи управління вмістом (CMS): у системах управління контентом кешування може бути реалізовано через Write Through. Коли адміністратор змінює або додає нові сторінки контенту, ці зміни не лише записуються в базу даних, але й одразу потрапляють у кеш, що забезпечує відображення змін на сайті без додаткових запитів до бази даних.
+ Інтернет-магазини: при зміні інформації про товар (наприклад, ціни чи наявності на складі), ці оновлення можуть автоматично записуватись в кеш і базу даних одночасно. Це дозволяє забезпечити, щоб користувач завжди отримував актуальну інформацію, навіть якщо вона не була ще обновлена у кеші.
+ Фінансові системи: у фінансових додатках, де важливо мати актуальні дані (наприклад, зміни балансу рахунку), Write Through патерн дозволяє синхронізувати кеш з базою даних. При оновленні балансу ці зміни записуються одразу в обидва місця, що мінімізує можливість отримання застарілих даних.

<ins>Розглянемо приклад використання Write Through для оновлення інформації про користувача в Redis та базі даних за допомогою C#.<ins/>
```csharp
using StackExchange.Redis;
using System;

public class UserService
{
    private IDatabase _cache;
    private IDatabase _database;

    public UserService()
    {
        // Підключення до Redis
        var connection = ConnectionMultiplexer.Connect("localhost");
        _cache = connection.GetDatabase();
        _database = connection.GetDatabase();
    }

    public void UpdateUserProfile(int userId, string newProfileData)
    {
        // Оновлення кешу
        _cache.StringSet($"user:{userId}", newProfileData);
        Console.WriteLine("Data updated in cache.");

        // Оновлення бази даних
        _database.StringSet($"user:{userId}", newProfileData);
        Console.WriteLine("Data updated in database.");
    }
}
```

У цьому прикладі ми оновлюємо профіль користувача одночасно в кеші та базі даних. Під час виклику методу UpdateUserProfile, нові дані спочатку зберігаються в кеші, а потім ці ж дані записуються в основну базу даних, забезпечуючи синхронізацію між ними.

### Переваги

+ Актуальність даних: оскільки кеш завжди синхронізується з базою даних при кожному оновленні, це дозволяє забезпечити актуальність і точність даних у обох місцях.
+ Простота реалізації: підхід Write Through простий у реалізації, оскільки дані завжди одночасно оновлюються в двох місцях, що спрощує логіку управління кешем.
+ Мінімізація ймовірності застарілих даних: оновлення відбувається синхронно, що виключає можливість відображення застарілих даних.

### Недоліки

+ Вища вартість запису: оскільки кожен запис здійснюється і в кеш, і в базу даних одночасно, це може збільшити час виконання операцій запису і навантаження на систему.
+ Зниження продуктивності при високому навантаженні: якщо система обробляє велику кількість операцій запису, синхронне оновлення кешу та бази даних може створити затримки та зменшити продуктивність.
+ Ризик блокування: оскільки кожен запис має бути записаний у дві системи, це може привести до потенційного блокування, особливо в умовах високого навантаження, що знижує загальну ефективність.

Таким чином, патерн Write Through підходить для ситуацій, де важливо мати постійну синхронізацію кешу з базою даних і забезпечити актуальність даних для користувачів, однак його застосування потребує більшої обчислювальної потужності та може знижувати продуктивність при великій кількості операцій запису.

## 3. Write Behind (Write Back)

Патерн ***Write Behind (також відомий як Write Back)*** полягає в тому, що дані спочатку записуються в кеш, а потім асинхронно оновлюються в базі даних через певний час або коли це зручно для системи. На відміну від Write Through, де зміни одразу відображаються в обох сховищах, в Write Behind кеш є основним місцем для зберігання даних, а зміни в базу даних здійснюються пізніше.

Цей підхід дозволяє знизити навантаження на базу даних, оскільки запис в базу даних виконується асинхронно і не блокує основну операцію. Основне завдання такого патерну — забезпечити ефективність обробки великої кількості записів і зменшити затримки при виконанні операцій з даними.

### Приклади застосування

+ Системи з високим навантаженням на запис: у великих платформах, таких як соціальні мережі або сервіси для обміну повідомленнями, де велика кількість користувачів постійно вносить зміни (наприклад, коментарі або статуси), Write Behind допомагає значно зменшити навантаження на базу даних. Зміни записуються в кеш, а потім, у фоновому режимі, ці дані записуються в основну базу.
+ Інтернет-магазини з великим обсягом транзакцій: у магазинах, де постійно змінюється інформація про товари, замовлення або користувачів, кеш може використовуватися для тимчасового зберігання змін. Зміни, що стосуються обробки замовлень або оновлення складу товарів, можуть бути спочатку записані в кеш, а потім асинхронно записані в базу даних.
+ Фінансові системи з регулярними оновленнями даних: для систем, де часто оновлюються фінансові дані, такі як зміни балансу рахунків або транзакції, Write Behind дозволяє обробляти великі обсяги інформації, зберігаючи їх спершу в кеші, а потім оновлюючи базу даних, коли це можливо, без блокування інших операцій.

<ins>Розглянемо приклад використання патерну Write Behind в C# для запису даних в кеш (Redis) та асинхронного оновлення в базі даних через фонову задачу.<ins/>
```csharp
using StackExchange.Redis;
using System;
using System.Threading.Tasks;

public class UserService
{
    private IDatabase _cache;
    private IDatabase _database;

    public UserService()
    {
        var connection = ConnectionMultiplexer.Connect("localhost");
        _cache = connection.GetDatabase();
        _database = connection.GetDatabase();
    }

    public void UpdateUserProfile(int userId, string newProfileData)
    {
        // Запис в кеш
        _cache.StringSet($"user:{userId}", newProfileData);
        Console.WriteLine("Data updated in cache.");

        // Асинхронне оновлення бази даних через фонову задачу
        Task.Run(() => UpdateDatabaseAsync(userId, newProfileData));
    }

    private async Task UpdateDatabaseAsync(int userId, string newProfileData)
    {
        // Затримка для симуляції асинхронного запису
        await Task.Delay(1000); // затримка для імітації асинхронної операції

        // Оновлення даних у базі даних
        _database.StringSet($"user:{userId}", newProfileData);
        Console.WriteLine("Data updated in database.");
    }
}
```
У цьому прикладі ми спочатку оновлюємо профіль користувача в кеші, а потім асинхронно оновлюємо ці дані в базі даних через фонову задачу. Такий підхід дозволяє швидко виконати операцію запису в кеш, а основну базу даних оновлювати пізніше.

### Переваги

+ Зниження навантаження на базу даних: основна перевага Write Behind полягає в тому, що зменшується кількість записів у базу даних, оскільки вони виконуються асинхронно в фоновому режимі.
+ Покращення продуктивності: оскільки дані спочатку записуються в кеш, користувач може одразу отримати результат, не чекаючи на завершення запису в базу даних.
+ Підвищена швидкість операцій запису: оскільки запис в кеш відбувається одразу, це дозволяє прискорити процеси, які вимагають великих обсягів запису.

### Недоліки

+ Можливість відставання даних: оскільки оновлення бази даних здійснюється асинхронно, можуть виникати ситуації, коли база даних має застарілу інформацію. Це може призвести до відсутності консистентності між кешем та базою даних на деякий час.
+ Необхідність в обробці помилок: якщо асинхронне оновлення бази даних не вдається (наприклад, через збій мережі), це може призвести до втрачених або некоректних даних, тому потрібні додаткові механізми для обробки помилок.
+ Складність синхронізації: оскільки зміни виконуються асинхронно, потрібно ретельно стежити за тим, щоб дані в кеші та базі даних були синхронізовані, і враховувати можливі проблеми з цілісністю даних.

Таким чином, патерн Write Behind є ефективним для систем з високим навантаженням, де важливо зберігати високу швидкість запису і обробки даних, але його використання потребує належного управління асинхронними процесами і синхронізацією кешу та бази даних.

## 4. Refresh Ahead

Патерн ***Refresh Ahead*** передбачає, що кеш регулярно оновлюється ще до того, як дані вийдуть із терміну придатності. Ідея цього патерну полягає в тому, що система передбачає необхідність оновлення кешу заздалегідь, забезпечуючи доступ до актуальних даних без затримок. Це дозволяє зменшити час очікування для користувачів, оскільки кеш завжди містить актуальну інформацію, навіть до того, як вона стане застарілою.

Зазвичай, цей підхід включає механізм, який періодично перевіряє, коли дані в кеші наближаються до свого терміну придатності (TTL), і перед оновленням кешу виконується фонове оновлення або завантаження нових даних. Це дозволяє уникнути затримок при запиті до кешу та підтримувати безперервну доступність актуальних даних.

### Приклади застосування

+ Системи онлайн-бронювання: у платформах для бронювання готелів або авіаквитків дані про наявність місць або цін можуть оновлюватися дуже часто. Для таких систем використовується Refresh Ahead для того, щоб кеш постійно оновлювався заздалегідь, поки ці дані ще не стали застарілими. Це дозволяє зменшити затримки при бронюванні, оскільки користувач отримує актуальну інформацію без додаткових запитів до бази даних.
+ Інтернет-магазини з великими асортиментами товарів: у магазинах з великою кількістю товарів, наприклад, електроніки або модного одягу, дані про наявність на складі, ціни або спеціальні пропозиції можуть змінюватися часто. Refresh Ahead використовується для забезпечення, щоб ці дані завжди були актуальними в кеші, оновлюючись ще до того, як вони стануть застарілими.
+ Фінансові сервіси: у фінансових системах, де постійно оновлюється інформація про баланси рахунків, курси валют або транзакції, Refresh Ahead дозволяє кешувати оновлені дані, перш ніж вони застаріють. Це забезпечує, щоб користувачі завжди отримували актуальні фінансові дані без затримок.

<ins>Розглянемо приклад використання Refresh Ahead для кешування даних про курси валют в C#. Кеш оновлюється асинхронно до того, як дані стануть застарілими.<ins/>
```csharp
using StackExchange.Redis;
using System;
using System.Threading.Tasks;

public class CurrencyService
{
    private IDatabase _cache;
    private IDatabase _database;
    private TimeSpan _cacheExpiry = TimeSpan.FromMinutes(5);

    public CurrencyService()
    {
        var connection = ConnectionMultiplexer.Connect("localhost");
        _cache = connection.GetDatabase();
        _database = connection.GetDatabase();
    }

    public async Task<string> GetCurrencyRateAsync(string currencyPair)
    {
        // Перевірка, чи є дані в кеші
        string cachedRate = _cache.StringGet(currencyPair);
        if (cachedRate != null)
        {
            Console.WriteLine("Data retrieved from cache.");
            return cachedRate;
        }

        // Якщо дані відсутні, завантажуємо їх з бази даних
        string rateFromDb = await FetchCurrencyRateFromDbAsync(currencyPair);
        
        // Збереження даних у кеш з оновленням
        _cache.StringSet(currencyPair, rateFromDb, _cacheExpiry);
        Console.WriteLine("Data retrieved from database and cached.");

        // Запуск фонової задачі для оновлення кешу
        RefreshCacheAhead(currencyPair);

        return rateFromDb;
    }

    private async Task<string> FetchCurrencyRateFromDbAsync(string currencyPair)
    {
        // Симуляція запиту до бази даних
        await Task.Delay(1000);  // затримка для імітації запиту
        return "1.21"; // Наприклад, курс EUR/USD
    }

    private void RefreshCacheAhead(string currencyPair)
    {
        Task.Run(async () =>
        {
            await Task.Delay(_cacheExpiry - TimeSpan.FromSeconds(10)); // Оновлення кешу перед терміном придатності
            string newRate = await FetchCurrencyRateFromDbAsync(currencyPair);
            _cache.StringSet(currencyPair, newRate, _cacheExpiry);
            Console.WriteLine("Cache refreshed ahead.");
        });
    }
}
```
У цьому прикладі дані про валютні курси спочатку завантажуються з бази даних, якщо їх немає в кеші. Після цього, завдяки механізму Refresh Ahead, кеш буде оновлено заздалегідь, щоб при наступному запиті до кешу користувач отримав актуальні дані. Процес оновлення відбувається фоново, коли дані наближаються до терміну придатності.

### Переваги

+ Зменшення затримок: оскільки кеш завжди оновлюється заздалегідь, користувач отримує актуальні дані без додаткових затримок, навіть якщо вони нещодавно змінилися.
+ Покращення користувацького досвіду: користувачі отримують найбільш актуальну інформацію, оскільки дані в кеші завжди оновлюються до того, як вони стануть застарілими.
+ Підвищення ефективності: запити до бази даних можуть бути зменшені, оскільки дані в кеші регулярно оновлюються, що дозволяє зменшити навантаження на базу даних.

### Недоліки

+ Використання додаткових ресурсів: регулярне оновлення кешу може споживати додаткові ресурси, що особливо важливо для великих систем з високими вимогами до продуктивності.
+ Необхідність точного управління часом оновлення: якщо кеш оновлюється занадто часто або занадто рідко, це може призвести до відставання даних або зайвих витрат ресурсів на оновлення.
+ Можливі проблеми з консистентністю: хоча кеш постійно оновлюється, можуть бути ситуації, коли в деяких частинах системи відображаються ще старі дані до того, як оновлення буде завершено.

Таким чином, Refresh Ahead є дуже корисним для систем, де важливо забезпечити миттєву доступність актуальних даних без затримок, але цей підхід потребує ретельного управління оновленнями кешу для досягнення оптимальної продуктивності.

## 5. Cache Invalidation

***Cache Invalidation*** — це процес видалення або оновлення даних у кеші, коли ці дані змінюються в основному сховищі (наприклад, в базі даних). Кеш може містити застарілі дані, і важливо мати механізм, який очищує або оновлює ці дані, щоб забезпечити їх актуальність. Існує кілька методів інвалідизації кешу:

1. Тайм-аут (TTL): кешовані дані мають обмежений час життя (Time to Live, TTL). Після закінчення цього часу дані в кеші вважаються застарілими і автоматично видаляються.
2. Поточна інвалідизація: дані в кеші очищуються або оновлюються, коли дані в основному сховищі змінюються. Це може бути досягнуто за допомогою подій або тригерів.
3. Ручне очищення: у деяких випадках інвалідизацію кешу можна здійснити вручну через API або спеціальні інтерфейси, коли адміністратор або система вирішує, що кеш треба очистити.

Цей підхід дозволяє уникнути ситуацій, коли в кеші містяться застарілі або неправильні дані, і гарантує, що користувачі завжди отримують актуальну інформацію.

### Приклади застосування

+ Електронна комерція: в інтернет-магазинах часто змінюються ціни на товари, наявність на складі або акційні пропозиції. Для того, щоб забезпечити користувачам доступ до актуальної інформації, використовують Cache Invalidation. Наприклад, коли ціна товару змінюється, кеш з ціною товару на сайті очищується або оновлюється, щоб користувач бачив актуальну ціну.
+ Системи управління контентом (CMS): у системах управління контентом, де часто оновлюються статті, новини або медіафайли, кешовані сторінки повинні бути інвалідовані, коли контент змінюється. Наприклад, після оновлення статті або додавання нових даних до блогу, кешований контент очищається, щоб користувачі отримали актуальну версію сторінки.
+ Фінансові сервіси: у фінансових системах, де дані змінюються часто (наприклад, курси валют, баланси рахунків), кеш повинен бути інвалідований кожного разу, коли ці дані оновлюються. Це дозволяє користувачам отримувати актуальні фінансові дані без затримок.

<ins>Розглянемо приклад використання Cache Invalidation в C# для оновлення кешу після зміни даних про користувача в базі даних.<ins/>
```csharp
using StackExchange.Redis;
using System;

public class UserService
{
    private IDatabase _cache;
    private IDatabase _database;

    public UserService()
    {
        var connection = ConnectionMultiplexer.Connect("localhost");
        _cache = connection.GetDatabase();
        _database = connection.GetDatabase();
    }

    public void UpdateUserProfile(int userId, string newProfileData)
    {
        // Оновлення бази даних
        _database.StringSet($"user:{userId}", newProfileData);
        Console.WriteLine("Data updated in database.");

        // Інвалідизація кешу після оновлення даних у базі
        _cache.KeyDelete($"user:{userId}");
        Console.WriteLine("Cache invalidated.");
    }

    public string GetUserProfile(int userId)
    {
        // Перевірка кешу
        string cachedProfile = _cache.StringGet($"user:{userId}");
        if (cachedProfile != null)
        {
            Console.WriteLine("Data retrieved from cache.");
            return cachedProfile;
        }

        // Якщо дані відсутні в кеші, завантажуємо з бази даних
        string profileFromDb = _database.StringGet($"user:{userId}");
        if (profileFromDb != null)
        {
            // Збереження даних у кеш
            _cache.StringSet($"user:{userId}", profileFromDb);
            Console.WriteLine("Data retrieved from database and cached.");
            return profileFromDb;
        }

        return "User not found";
    }
}
```
У цьому прикладі, після того як ми оновлюємо дані користувача в базі даних, ми інвалідовуємо кеш для цього користувача, видаляючи відповідний ключ з кешу. Це дозволяє уникнути надання застарілої інформації і гарантує, що при наступному запиті до кешу дані будуть завантажені з бази даних і знову кешовані.

### Переваги

+ Актуальність даних: завдяки інвалідизації кешу, ми завжди гарантуємо, що кеш містить актуальну інформацію, що є важливим для додатків, які працюють з часто змінюваними даними.
+ Контроль над кешем: система може точно визначати, коли кеш потрібно очищати або оновлювати, що дозволяє уникати ситуацій з некоректними даними.
+ Мінімізація навантаження на базу даних: кеш може зберігати дані тільки на короткий період, тим самим знижуючи навантаження на базу даних, оскільки старі дані будуть видалені, коли вони більше не потрібні.

### Недоліки

+ Виконання додаткових операцій: інвалідизація кешу потребує додаткових операцій, що може збільшити складність системи та додаткові затримки.
+ Потенційні помилки при синхронізації: якщо інвалідизація кешу не реалізована належним чином, можуть виникнути ситуації, коли кеш не оновлюється вчасно, що може призвести до надання застарілої або некоректної інформації.
+ Навантаження на систему при частих оновленнях: якщо система дуже часто інвалідовує кеш (особливо у випадках з великими обсягами даних), це може призвести до додаткових навантажень на сервери і знижувати загальну продуктивність.

Таким чином, Cache Invalidation є важливим патерном для забезпечення консистентності даних між кешем і базою даних, проте потребує ретельного управління для запобігання проблемам з ефективністю та синхронізацією даних.

## 6. Time-based Expiration

***Time-based Expiration (істинне термінове закінчення)*** є стратегією кешування, при якій дані в кеші мають обмежений час життя, що визначається параметром Time to Live (TTL). Коли цей час вичерпано, кешовані дані автоматично видаляються або вважаються застарілими. Це дозволяє забезпечити, що кеш містить лише свіжі дані, і усуває проблему з накопиченням застарілої інформації.

Під час реалізації Time-based Expiration, кожен елемент у кеші зберігається лише до визначеного терміну, після чого він автоматично очищується. Цей механізм допомагає підтримувати актуальність даних без необхідності вручну їх інвалідовувати, оскільки час життя кешу сам по собі контролює актуальність.

### Приклади застосування:

+ Системи управління сесіями користувачів: у веб-застосунках, де використовується кешування сесій, дані користувача можуть бути кешовані на короткий період, наприклад, протягом 30 хвилин або години. Це дозволяє зберігати дані про активну сесію без необхідності постійно звертатися до бази даних, одночасно гарантуючи, що застарілі сесії не зберігаються в кеші.
+ API з кешуванням результатів запитів: у системах, де часто виконуються однакові запити до бази даних або зовнішніх API, можна використовувати Time-based Expiration для кешування результатів. Наприклад, в мобільних або веб-додатках часто використовуються кешовані відповіді від API для запитів, які не потребують миттєвого оновлення. Результати можуть зберігатися в кеші протягом декількох хвилин або годин, після чого вони автоматично оновлюються.
+ Інтернет-магазини: для кешування інформації про наявність товару на складі або актуальних знижок можна встановити обмежений час життя для кешу. Кеш може оновлюватися раз на кілька хвилин або годин, залежно від того, як часто змінюються ці дані. Це дозволяє швидко отримувати дані без зайвих звернень до бази даних, при цьому гарантуючи, що інформація в кеші не буде застарілою.

<ins>Розглянемо приклад використання Time-based Expiration в C# з використанням Redis для кешування результатів API запитів.<ins/>
```csharp
using StackExchange.Redis;
using System;

public class ApiCacheService
{
    private IDatabase _cache;

    public ApiCacheService()
    {
        var connection = ConnectionMultiplexer.Connect("localhost");
        _cache = connection.GetDatabase();
    }

    public string GetApiResponse(string apiUrl)
    {
        // Перевірка наявності кешованої відповіді
        string cachedResponse = _cache.StringGet(apiUrl);
        if (cachedResponse != null)
        {
            Console.WriteLine("Data retrieved from cache.");
            return cachedResponse;
        }

        // Якщо відповіді немає в кеші, отримуємо її через API
        string apiResponse = FetchApiResponse(apiUrl);
        
        // Збереження відповіді в кеш з терміном придатності 5 хвилин
        _cache.StringSet(apiUrl, apiResponse, TimeSpan.FromMinutes(5));
        Console.WriteLine("Data retrieved from API and cached.");

        return apiResponse;
    }

    private string FetchApiResponse(string apiUrl)
    {
        // Симуляція запиту до зовнішнього API
        return $"Response from {apiUrl}";
    }
}
```
У цьому прикладі, ми отримуємо дані з API і кешуємо їх на 5 хвилин за допомогою Redis. Якщо дані вже є в кеші, вони повертаються без запиту до API. Після 5 хвилин кеш автоматично видаляється, і при наступному запиті дані знову отримуються з API та кешуються знову.

### Переваги

+ Автоматичне очищення кешу: кеш не містить застарілих даних, оскільки вони автоматично видаляються після закінчення терміну життя. Це допомагає уникнути зберігання непотрібної або неактуальної інформації.
+ Простота в реалізації: Time-based Expiration є відносно простим для реалізації, оскільки не потребує складних механізмів для інвалідизації або синхронізації даних між кешем і базою даних.
+ Оптимізація використання кешу: завдяки встановленому терміну дії кешу, він не накопичує застарілі дані, що зменшує обсяг збережених в кеші елементів і покращує ефективність системи.

### Недоліки

+ Можливість отримання застарілих даних: якщо термін життя кешу занадто великий, це може призвести до того, що користувачі будуть отримувати старі дані до того, як кеш оновиться. Це особливо критично для додатків, де важлива актуальність інформації.
+ Потрібна точність налаштувань TTL: налаштування TTL потребує уважності, оскільки занадто короткий час може призвести до частих запитів до бази даних, а занадто довгий — до отримання застарілих даних.
+ Навантаження на систему при частому оновленні: якщо в системі занадто багато даних з малим TTL, це може призвести до високого навантаження на кеш-систему, оскільки потрібно часто оновлювати дані.

Таким чином, Time-based Expiration є дуже корисним підходом для кешування, коли є потреба в автоматичному очищенні кешу після певного часу, але його використання вимагає ретельного налаштування терміну життя даних, щоб забезпечити оптимальну продуктивність і актуальність даних у системі.

## 7. LRU (Least Recently Used)

***LRU (Least Recently Used)*** — це алгоритм управління кешем, який обирає для видалення з кешу ті елементи, які не використовувались найдовше. Кешування за допомогою LRU гарантує, що в кеші завжди будуть зберігатися найактивніше використовувані дані, в той час як застарілі або рідко використовувані елементи будуть видалені.

Механізм LRU зазвичай реалізується за допомогою структури даних, яка дозволяє відстежувати порядок використання елементів кешу. Однією з найефективніших структур для цього є двосторонній зв'язний список, де кожен елемент представляє пару "ключ-значення". Найновіше використані елементи знаходяться на початку списку, а найменш використовувані — в кінці. Коли кеш заповнюється і потрібно видалити елемент, вибирається той, що знаходиться в кінці списку.

### Приклади застосування

+ Кешування запитів до бази даних: у системах, де часто виконуються однакові запити до бази даних, кешування результатів запитів може використовувати LRU для управління обмеженнями пам'яті. Якщо кеш заповнений, і потрібно видалити старі дані, буде обраний той результат, який не запитувався найбільше останнім часом.
+ Веб-браузери: веб-браузери використовують LRU для кешування веб-сторінок, зображень та інших ресурсів. Це дозволяє швидко завантажувати раніше переглянуті сторінки, зберігаючи при цьому обмежений розмір кешу. Сторінки, які не були використані найбільш довгий час, видаляються з кешу, звільняючи місце для нових.
+ Мобільні додатки для кешування медіафайлів: у мобільних додатках для зберігання медіафайлів, таких як фотографії або відео, LRU може використовуватись для кешування файлів, що часто використовуються. Наприклад, в галереях зображень на мобільних пристроях кешуються тільки останні переглянуті або редаговані зображення, а старі, які рідко відкриваються, видаляються з кешу.

<ins>Розглянемо приклад використання алгоритму LRU для кешування в C# за допомогою стандартної бібліотеки. Для реалізації LRU використовуватимемо Dictionary і LinkedList.<ins/>
```csharp
using System;
using System.Collections.Generic;

public class LruCache<TKey, TValue>
{
    private readonly int _capacity;
    private readonly Dictionary<TKey, LinkedListNode<KeyValuePair<TKey, TValue>>> _cache;
    private readonly LinkedList<KeyValuePair<TKey, TValue>> _orderList;

    public LruCache(int capacity)
    {
        _capacity = capacity;
        _cache = new Dictionary<TKey, LinkedListNode<KeyValuePair<TKey, TValue>>>(capacity);
        _orderList = new LinkedList<KeyValuePair<TKey, TValue>>();
    }

    public TValue Get(TKey key)
    {
        if (!_cache.ContainsKey(key)) return default(TValue);

        var node = _cache[key];
        _orderList.Remove(node);
        _orderList.AddFirst(node); // переміщаємо елемент на початок списку
        return node.Value.Value;
    }

    public void Put(TKey key, TValue value)
    {
        if (_cache.ContainsKey(key))
        {
            // Оновлення існуючого елемента
            var node = _cache[key];
            _orderList.Remove(node);
            _orderList.AddFirst(node); // переміщаємо елемент на початок списку
            node.Value = new KeyValuePair<TKey, TValue>(key, value);
        }
        else
        {
            // Додавання нового елемента
            if (_cache.Count >= _capacity)
            {
                // Видалення найменш використовуваного елемента (останній в списку)
                var lastNode = _orderList.Last;
                _cache.Remove(lastNode.Value.Key);
                _orderList.RemoveLast();
            }

            var newNode = new KeyValuePair<TKey, TValue>(key, value);
            var node = new LinkedListNode<KeyValuePair<TKey, TValue>>(newNode);
            _orderList.AddFirst(node);
            _cache[key] = node;
        }
    }
}

class Program
{
    static void Main()
    {
        var lruCache = new LruCache<int, string>(3);
        lruCache.Put(1, "A");
        lruCache.Put(2, "B");
        lruCache.Put(3, "C");

        Console.WriteLine(lruCache.Get(1)); // A
        lruCache.Put(4, "D"); // Видаляється 2, додається 4

        Console.WriteLine(lruCache.Get(2)); // default (null) - 2 видалено
        Console.WriteLine(lruCache.Get(3)); // C
        Console.WriteLine(lruCache.Get(4)); // D
    }
}
```
У цьому прикладі ми використовуємо Dictionary для швидкого доступу до елементів кешу та LinkedList для підтримки порядку використання елементів. Кожен елемент в кеші зберігається разом з інформацією про порядок його використання, і коли потрібно видалити найменш використовуваний елемент, він просто видаляється з кінця списку.

### Переваги

+ Оптимізація використання пам'яті: за допомогою алгоритму LRU кеш завжди містить найбільш актуальні дані, що зменшує ймовірність витрати пам'яті на рідко використовувані елементи.
+ Простота реалізації: алгоритм LRU простий у реалізації та використанні, особливо якщо є необхідність обмежити розмір кешу.
+ Ефективність для систем з обмеженою пам'яттю: ідеально підходить для систем, де потрібно контролювати обсяг кешованих даних і гарантувати, що пам'ять не заповниться непотрібними елементами.

### Недоліки

+ Проблеми з великою кількістю елементів: якщо кеш працює з великою кількістю елементів і часто змінюються використані елементи, LRU може стати не таким ефективним, оскільки перевірка й оновлення порядку використання може займати багато часу.
+ Невдача при рівномірному доступі: якщо елементи кешу використовуються рівномірно, то LRU може не давати оптимальних результатів, оскільки старі елементи будуть видалятись навіть якщо вони потрібні.
+ Потрібна додаткова пам'ять для відстеження порядку: для збереження порядку використання елементів, LRU вимагає додаткових структур даних, таких як список або черга, що може збільшити споживання пам'яті.

Таким чином, LRU є ефективним підходом для кешування в ситуаціях, де необхідно обмежити пам'ять, зберігаючи лише найбільш часто використовувані дані, але цей алгоритм може бути не так ефективний при великих обсягах даних або рівномірному доступі до них.

## 8. LFU (Least Frequently Used)

***LFU (Least Frequently Used)*** — це алгоритм управління кешем, який вибирає для видалення з кешу елементи, що використовуються найменше. На відміну від LRU, який видаляє елементи на основі часу їх останнього використання, LFU орієнтується на кількість звернень до кожного елемента. Тобто елемент, який використовується рідше за інших, буде видалений з кешу, коли потрібно звільнити місце для нових даних.

Для реалізації LFU зазвичай використовуються структури даних, які можуть ефективно відстежувати кількість звернень до кожного елемента, наприклад, хеш-таблиці для зберігання елементів і пріоритетні черги або двосторонні списки для відстеження їх частоти використання.

Механізм роботи LFU полягає в тому, що кожен елемент кешу супроводжується лічильником, що збільшується при кожному зверненні до цього елемента. Коли кеш заповнюється і потрібно видалити елемент, вибирається той, чия частота використання найменша.

### Приклади застосування

+ Кешування запитів до API: у додатках, які взаємодіють із зовнішніми API, де деякі запити можуть бути популярними, а інші рідко використовуваними, LFU дозволяє ефективно керувати кешем запитів. Наприклад, якщо є багато запитів до одного й того ж ресурсу, вони будуть залишатися в кеші, а рідко використовувані запити будуть видалятися для звільнення місця.
+ Інтернет-магазини: у магазинах з великим асортиментом товарів LFU можна використовувати для кешування найпопулярніших товарів або категорій. Продукти, які найчастіше переглядаються або купуються, будуть зберігатися в кеші довше, ніж ті, що не мають високого попиту. Це забезпечує швидший доступ до популярних товарів і знижує навантаження на сервер.
+ Веб-браузери: у браузерах кешуються зображення, скрипти, стилі та інші ресурси веб-сторінок. LFU допомагає зберігати в кеші найбільш часто використовувані ресурси, покращуючи швидкість завантаження сторінок, одночасно звільняючи місце для менш використовуваних елементів.

<ins>Розглянемо приклад використання LFU для кешування запитів до бази даних. Для зберігання частоти використання елементів ми будемо використовувати словник і пріоритетну чергу, що дозволяє ефективно видаляти найменш часто використовувані елементи.<ins/>
```csharp
using System;
using System.Collections.Generic;

public class LfuCache<TKey, TValue>
{
    private readonly int _capacity;
    private readonly Dictionary<TKey, TValue> _cache;
    private readonly Dictionary<TKey, int> _frequency;
    private readonly SortedList<int, LinkedList<TKey>> _frequencyList;

    public LfuCache(int capacity)
    {
        _capacity = capacity;
        _cache = new Dictionary<TKey, TValue>();
        _frequency = new Dictionary<TKey, int>();
        _frequencyList = new SortedList<int, LinkedList<TKey>>();
    }

    public TValue Get(TKey key)
    {
        if (!_cache.ContainsKey(key)) return default(TValue);

        // Оновлення частоти використання
        int freq = _frequency[key];
        _frequency[key] = freq + 1;

        // Переміщаємо ключ до нового списку за оновленою частотою
        _frequencyList[freq].Remove(key);
        if (!_frequencyList.ContainsKey(freq + 1))
            _frequencyList[freq + 1] = new LinkedList<TKey>();
        _frequencyList[freq + 1].AddLast(key);

        return _cache[key];
    }

    public void Put(TKey key, TValue value)
    {
        if (_cache.ContainsKey(key))
        {
            _cache[key] = value;
            return;
        }

        if (_cache.Count >= _capacity)
        {
            // Видалення найменш часто використовуваного елемента
            var lfuList = _frequencyList[0];
            var leastUsedKey = lfuList.First.Value;
            lfuList.RemoveFirst();
            _cache.Remove(leastUsedKey);
            _frequency.Remove(leastUsedKey);
        }

        _cache[key] = value;
        _frequency[key] = 1;
        if (!_frequencyList.ContainsKey(1))
            _frequencyList[1] = new LinkedList<TKey>();
        _frequencyList[1].AddLast(key);
    }
}

class Program
{
    static void Main()
    {
        var lfuCache = new LfuCache<int, string>(3);
        lfuCache.Put(1, "A");
        lfuCache.Put(2, "B");
        lfuCache.Put(3, "C");

        Console.WriteLine(lfuCache.Get(1)); // A
        lfuCache.Put(4, "D"); // Видаляється 2, додається 4

        Console.WriteLine(lfuCache.Get(2)); // default (null) - 2 видалено
        Console.WriteLine(lfuCache.Get(3)); // C
        Console.WriteLine(lfuCache.Get(4)); // D
    }
}
```
У цьому коді ми реалізуємо LFU кеш, де використовуємо два словники: один для зберігання значень (_cache), інший для частоти використання ключів (_frequency). Для відстеження порядку елементів за їх частотою використання ми використовуємо SortedList. Коли кеш заповнений, видаляється елемент з найменшою частотою використання.

### Переваги

+ Ефективне використання пам'яті: LFU гарантує, що в кеші зберігаються тільки найпопулярніші елементи, що дозволяє економити пам'ять для рідко використовуваних даних.
+ Підвищення продуктивності: за допомогою LFU можна забезпечити швидкий доступ до найчастіше використовуваних даних, що значно покращує продуктивність системи в разі високої популярності деяких елементів.
+ Контроль за частотою використання: LFU дозволяє точно відстежувати, які елементи використовуються найчастіше, і підтримувати їх у кеші, забезпечуючи баланс між новими і старими елементами.

### Недоліки

+ Висока складність реалізації: порівняно з LRU, LFU важче реалізувати через необхідність відстеження частоти використання елементів і підтримки даних у структурі, що може ускладнити код.
+ Навантаження на систему при великій кількості елементів: якщо кеш містить велику кількість елементів, LFU може призвести до додаткових витрат часу для обчислення частоти використання і переміщення елементів між різними списками.
+ Не завжди оптимальний для рідко використовуваних даних: якщо дані використовуються рівномірно, алгоритм може не працювати оптимально, оскільки він не враховує змінну популярність елементів з часом.

Таким чином, LFU — це ефективний алгоритм для кешування, коли важливо зберігати в кеші найпопулярніші дані, однак його реалізація може бути складною, а ефективність — обмеженою в ситуаціях з рівномірним використанням елементів.

## 9. Read Through

***Read Through*** — це патерн кешування, при якому дані спочатку перевіряються в кеші. Якщо ці дані знайдені в кеші, вони негайно повертаються користувачу. Якщо дані відсутні в кеші, система здійснює запит до основного сховища (наприклад, бази даних або API), отримує необхідні дані, кешує їх для майбутніх запитів і повертає результат користувачу.

Цей підхід дозволяє спростити процес доступу до даних, оскільки користувачі завжди отримують найсвіжіші дані, і лише в разі необхідності здійснюється запит до основної бази даних для оновлення кешу. Основна мета Read Through — це забезпечити зручний доступ до даних, не турбуючись про те, чи є ці дані в кеші, при цьому підтримуючи кеш актуальним.

### Приклади застосування

+ Інтернет-магазини: у інтернет-магазинах дані про товари, їх ціни та наявність на складі можуть часто оновлюватися. Використовуючи Read Through кешування, магазин може автоматично перевіряти наявність цих даних у кеші перед тим, як робити запит до бази даних. Якщо дані в кеші є, вони негайно повертаються користувачу, якщо ні — виконуються запити до бази даних, і нові дані кешуються для наступного використання.
+ Системи управління контентом (CMS): у CMS, де часто оновлюється контент (статті, новини, коментарі), кешування через Read Through дозволяє скоротити час завантаження сторінок. При цьому, якщо зміст статті не був змінений, дані з кешу надаються користувачам, а застарілі або нові дані отримуються з бази даних тільки в разі необхідності.
+ Соціальні мережі: у соціальних мережах дані про профілі користувачів, пости, лайки можуть бути кешовані для швидшого доступу. За допомогою Read Through кешування дані про профіль спочатку шукаються в кеші. Якщо профіль користувача вже кешований, він повертається з кешу, а в іншому випадку — запит здійснюється до бази даних для отримання найсвіжішої інформації.

<ins>Розглянемо приклад Read Through кешування за допомогою C# з використанням Redis. У цьому прикладі дані про користувача будуть зберігатися в кеші, і якщо вони відсутні, система отримає їх з бази даних.<ins/>
```csharp
using StackExchange.Redis;
using System;

public class UserService
{
    private IDatabase _cache;
    private IDatabase _database;

    public UserService()
    {
        // Підключення до Redis
        var connection = ConnectionMultiplexer.Connect("localhost");
        _cache = connection.GetDatabase();
        _database = connection.GetDatabase();
    }

    public string GetUserProfile(int userId)
    {
        // Перевірка кешу
        string cachedProfile = _cache.StringGet($"user:{userId}");
        if (cachedProfile != null)
        {
            Console.WriteLine("Data retrieved from cache.");
            return cachedProfile;
        }

        // Якщо дані відсутні в кеші, завантажуємо їх з бази даних
        string profileFromDb = _database.StringGet($"user:{userId}");
        if (profileFromDb != null)
        {
            // Збереження даних у кеш
            _cache.StringSet($"user:{userId}", profileFromDb, TimeSpan.FromMinutes(30));
            Console.WriteLine("Data retrieved from database and cached.");
            return profileFromDb;
        }

        return "User not found";
    }
}
```
У цьому прикладі ми перевіряємо, чи є дані про користувача в кеші Redis. Якщо дані є, вони повертаються з кешу. Якщо дані відсутні, ми отримуємо їх з бази даних, зберігаємо у кеші та повертаємо користувачу.

### Переваги

+ Простота в реалізації: Read Through легко реалізувати, оскільки система автоматично перевіряє кеш і надає актуальні дані, коли це необхідно.
+ Покращення швидкості доступу до даних: оскільки кешовані дані повертаються швидше за запити до бази даних, це значно прискорює доступ до інформації для користувачів.
+ Автоматичне оновлення кешу: кеш автоматично оновлюється, коли дані відсутні або стають застарілими, що дозволяє забезпечити актуальність кешованої інформації.
+ Зниження навантаження на базу даних: оскільки часто запитувані дані зберігаються в кеші, це зменшує навантаження на основну базу даних.

### Недоліки

+ Необхідність в управлінні кешем: необхідно правильно налаштувати час життя кешу та механізм оновлення даних для уникнення ситуацій із застарілою інформацією.
+ Можливість неактуальних даних: якщо кеш не оновлюється вчасно, користувач може отримати застарілу інформацію, якщо система не реалізує механізм автоматичного очищення або перевірки даних у кеші.
+ Збільшене використання пам'яті: кешування значної кількості даних може вимагати великих обсягів пам'яті, особливо при великих системах, що обробляють великі обсяги інформації.

Read Through є простим і ефективним патерном кешування, який дозволяє зменшити навантаження на базу даних, зберігаючи актуальність кешованих даних і покращуючи загальну продуктивність системи. Однак для його ефективного використання необхідно налаштувати механізми очищення та оновлення кешу для запобігання проблемам з некоректними даними.

## 10. Dual-Write

***Dual-Write*** — це патерн кешування, при якому дані записуються одночасно і в кеш, і в основне сховище даних (наприклад, базу даних). Під час операцій запису система зберігає нові або оновлені дані як у кеші, так і в базі даних. Це забезпечує, щоб кеш і база даних були синхронізовані, що дає змогу зменшити затримки при доступі до даних і підвищити ефективність системи.

Механізм Dual-Write гарантує, що будь-яка зміна в даних зберігається одночасно в двох місцях, що допомагає забезпечити актуальність даних і в кеші, і в основній базі. Цей підхід також знижує ймовірність втрати або неактуальності даних, оскільки одночасно з оновленням в основному сховищі дані автоматично актуалізуються в кеші.

### Приклади застосування

+ Системи електронної комерції: в інтернет-магазинах важливо забезпечити, щоб інформація про ціни, наявність товарів на складі або знижки була актуальна як у базі даних, так і в кеші. При зміні ціни або доступності товару Dual-Write гарантує, що ці зміни будуть записані одночасно в базу даних і кеш, що дозволяє швидко отримувати актуальну інформацію користувачам без необхідності запитувати базу даних кожен раз.
+ Фінансові платформи: у фінансових додатках, де дані про баланси рахунків, транзакції або курси валют можуть змінюватися часто, Dual-Write дозволяє зберігати актуальну інформацію в кеші для швидкого доступу, одночасно оновлюючи основну базу даних. Це гарантує, що всі зміни записуються без затримок і консистентність даних підтримується на обох рівнях.
+ Соціальні мережі: в соціальних мережах кешуються профілі користувачів, пости, коментарі. При оновленні профілю користувача або зміни посту Dual-Write гарантує, що нові дані зберігаються не лише в кеші для швидкого доступу, але й у базі даних для забезпечення довгострокової консистентності та збереження даних.

<ins>Розглянемо приклад використання Dual-Write для оновлення даних користувача в базі даних і кеші за допомогою C#. Для цього використаємо Redis для кешування та просту базу даних для зберігання даних.<ins/>
```csharp
using StackExchange.Redis;
using System;

public class UserService
{
    private IDatabase _cache;
    private IDatabase _database;

    public UserService()
    {
        var connection = ConnectionMultiplexer.Connect("localhost");
        _cache = connection.GetDatabase();
        _database = connection.GetDatabase();
    }

    public void UpdateUserProfile(int userId, string newProfileData)
    {
        // Оновлення в базі даних
        _database.StringSet($"user:{userId}", newProfileData);
        Console.WriteLine("Data updated in database.");

        // Оновлення в кеші
        _cache.StringSet($"user:{userId}", newProfileData);
        Console.WriteLine("Data updated in cache.");
    }

    public string GetUserProfile(int userId)
    {
        // Перевірка кешу
        string cachedProfile = _cache.StringGet($"user:{userId}");
        if (cachedProfile != null)
        {
            Console.WriteLine("Data retrieved from cache.");
            return cachedProfile;
        }

        // Якщо дані відсутні в кеші, завантажуємо їх з бази даних
        string profileFromDb = _database.StringGet($"user:{userId}");
        if (profileFromDb != null)
        {
            // Збереження даних у кеш
            _cache.StringSet($"user:{userId}", profileFromDb);
            Console.WriteLine("Data retrieved from database and cached.");
            return profileFromDb;
        }

        return "User not found";
    }
}

class Program
{
    static void Main()
    {
        var userService = new UserService();
        
        // Оновлення профілю користувача
        userService.UpdateUserProfile(1, "New Profile Data");

        // Отримання профілю з кешу або бази даних
        Console.WriteLine(userService.GetUserProfile(1)); // New Profile Data
    }
}
```
У цьому прикладі ми оновлюємо профіль користувача в базі даних і кеші одночасно. Це забезпечує, щоб дані були актуальні в обох місцях, і при наступному запиті користувача вони можуть бути отримані швидко з кешу.

### Переваги

+ Гарантована консистентність даних: оскільки дані записуються одночасно в кеш і в базу даних, це зменшує ймовірність того, що кеш і база даних міститимуть різну інформацію.
+ Швидкий доступ до актуальних даних: кеш забезпечує швидкий доступ до даних, тому користувачі отримують актуальну інформацію без затримок при запитах до бази даних.
+ Мінімізація затримок при записі: запис даних одночасно в дві системи може зменшити затримки, оскільки це дозволяє обробляти дані швидше, без необхідності виконувати окремі запити на кожен ресурс.

### Недоліки

+ Складність синхронізації: потрібно забезпечити, щоб кеш і база даних завжди були синхронізовані. У разі помилки при записі даних в одну зі систем може виникнути проблема з консистентністю.
+ Високе навантаження на систему: оскільки кожен запис відбувається в двох місцях одночасно, це може призвести до додаткового навантаження на сервери бази даних і кешу, особливо при високому обсязі запитів.
+ Можливість непотрібних записів: якщо система часто записує дані в кеш і базу даних, можуть виникнути ситуації, коли кеш містить застарілу інформацію, яку важко оновити вчасно.

Таким чином, Dual-Write — це потужний патерн для забезпечення актуальності даних як в кеші, так і в основному сховищі. Однак його реалізація вимагає додаткової уваги до синхронізації і управління навантаженням на систему, щоб уникнути потенційних проблем з продуктивністю та консистентністю.

## 11. Pre-Loading (Pre-caching)

