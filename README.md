# 12 поширених патернів кешування

### Вступ

Кешування є важливим інструментом для оптимізації роботи з даними в сучасних інформаційних системах. Завдяки кешуванню можна значно зменшити навантаження на бази даних і знизити час відповіді на запити користувачів, що є критичним фактором для забезпечення високої продуктивності додатків та веб-сайтів. Однак правильний вибір стратегії кешування залежить від багатьох факторів, таких як тип даних, частота доступу до них, вимоги до актуальності інформації та специфіка навантаження на систему.

У цій доповіді розглядаються 12 основних патернів кешування, які є найбільш поширеними у практиці розробки програмного забезпечення та роботи з базами даних. Кожен з цих патернів має свої особливості та може бути використаний для досягнення різних цілей — від зниження навантаження на сервери до забезпечення актуальності даних у системах з високим навантаженням. Важливо розуміти, який саме патерн краще підходить для конкретної ситуації, щоб ефективно використовувати кешування для досягнення бажаних результатів.

Ця доповідь надасть огляд кожного з цих патернів, їх переваги та недоліки, а також практичні приклади застосування, що дозволить краще зрозуміти, як кешування може бути інтегроване в сучасні системи для оптимізації роботи з даними.

## 1. Cache Aside (Lazy Loading)

Патерн ***Cache Aside (або Lazy Loading)*** передбачає, що кешування здійснюється на стороні додатка. У цьому випадку кеш не заповнюється автоматично, а дані завантажуються в кеш тільки в момент першого запиту. Коли додаток запитує дані, він спочатку перевіряє, чи є вони в кеші. Якщо дані знайдені, вони повертаються з кешу, що значно прискорює процес доступу. Якщо ж дані відсутні в кеші, додаток звертається до бази даних, отримує потрібну інформацію, записує її в кеш для подальших запитів і повертає результат користувачу.

Цей підхід є "ледачим", тому що дані не завантажуються в кеш до тих пір, поки в них не виникне реальна потреба, що дозволяє економити ресурси, завантажуючи кеш лише актуальними даними.

### Приклади застосування

+ Пошукові системи: у пошукових системах кешування результатів запитів може використовувати патерн Cache Aside. Коли користувач запитує якусь інформацію, система перевіряє, чи є результат цього запиту в кеші. Якщо результат є, він негайно віддається з кешу. Якщо результату немає, пошукова система звертається до бази даних або виконує запит на індексовані сторінки і зберігає отриману відповідь у кеші для подальших запитів.
+ Електронна комерція: у магазинах, що продають товари, кешування даних товарів (наприклад, ціни, наявність на складі) може використовувати цей патерн. Коли клієнт запитує інформацію про продукт, система перевіряє, чи є ці дані в кеші. Якщо вони відсутні, система запитує базу даних і додає дані в кеш.
+ Соціальні мережі: в соціальних мережах кешування профілів користувачів або постів може використовувати цей патерн. Коли інший користувач хоче побачити профіль, система перевіряє наявність цього профілю в кеші. Якщо дані є, вони віддаються з кешу, інакше вони завантажуються з основної бази даних.

<ins>Розглянемо приклад використання патерну Cache Aside на прикладі мови програмування C# з кешем Redis для зберігання даних про користувача.<ins/>

```
using StackExchange.Redis;
using System;

public class UserService
{
    private IDatabase _cache;
    private IDatabase _database;

    public UserService()
    {
        // Підключення до Redis
        var connection = ConnectionMultiplexer.Connect("localhost");
        _cache = connection.GetDatabase();
        _database = connection.GetDatabase();
    }

    public string GetUserProfile(int userId)
    {
        // Перевірка кешу
        string cachedProfile = _cache.StringGet($"user:{userId}");
        if (cachedProfile != null)
        {
            Console.WriteLine("Data retrieved from cache.");
            return cachedProfile;
        }

        // Якщо в кеші немає даних, завантажуємо з бази даних
        string profileFromDb = _database.StringGet($"user:{userId}");
        if (profileFromDb != null)
        {
            // Збереження результату в кеш
            _cache.StringSet($"user:{userId}", profileFromDb, TimeSpan.FromMinutes(30));
            Console.WriteLine("Data retrieved from database and cached.");
            return profileFromDb;
        }

        return "User not found";
    }
}
```
У цьому коді ми перевіряємо кеш (Redis) для наявності профілю користувача за ID. Якщо дані не знайдені, вони завантажуються з основної бази даних і кешуються для майбутніх запитів.

### Переваги:

+ Економія ресурсів: кеш завантажується тільки при потребі, що дозволяє уникнути непотрібного заповнення кешу.
+ Покращення продуктивності: перші запити можуть бути більш повільними (через завантаження з бази даних), але наступні запити будуть оброблятися набагато швидше завдяки кешуванню.
+ Мінімізація навантаження на базу даних: оскільки кеш не зберігає всі дані, а тільки ті, до яких часто звертаються, це дозволяє зменшити навантаження на базу даних.

### Недоліки:

+ Тенденція до "холодного кешу": якщо система не часто звертається до певних даних, вони можуть бути відсутні в кеші, що спричинить звернення до бази даних навіть для часто запитуваних даних.
+ Неактуальні дані: якщо дані в кеші старі або не були оновлені, це може призвести до надання застарілої інформації. Для цього потрібно розробити стратегію оновлення кешу або очищення за певний час.
+ Необхідність реалізації додаткової логіки: для ефективного використання кешування може знадобитись додатковий код для управління кешем, що збільшує складність системи.

Загалом, патерн Cache Aside підходить для ситуацій, де не завжди є потреба в кешуванні всіх даних, а лише тих, що найчастіше запитуються, що дозволяє забезпечити ефективність і знижене навантаження на сервери та бази даних.

## 2. Write Through

Патерн ***Write Through*** передбачає, що кожен запис у кеш здійснюється одночасно і в основну базу даних. Кожного разу, коли додаток записує нові або оновлені дані, ці зміни відразу відображаються не лише в кеші, але й у базі даних. Це забезпечує постійну синхронізацію між кешем та основним сховищем даних.

Основна ідея цього підходу полягає в тому, що дані зберігаються в кеші так само, як і в базі даних. Такий підхід дозволяє забезпечити актуальність даних, оскільки кожна зміна відображається у обох місцях одночасно.

### Приклади застосування

+ Системи управління вмістом (CMS): у системах управління контентом кешування може бути реалізовано через Write Through. Коли адміністратор змінює або додає нові сторінки контенту, ці зміни не лише записуються в базу даних, але й одразу потрапляють у кеш, що забезпечує відображення змін на сайті без додаткових запитів до бази даних.
+ Інтернет-магазини: при зміні інформації про товар (наприклад, ціни чи наявності на складі), ці оновлення можуть автоматично записуватись в кеш і базу даних одночасно. Це дозволяє забезпечити, щоб користувач завжди отримував актуальну інформацію, навіть якщо вона не була ще обновлена у кеші.
+ Фінансові системи: у фінансових додатках, де важливо мати актуальні дані (наприклад, зміни балансу рахунку), Write Through патерн дозволяє синхронізувати кеш з базою даних. При оновленні балансу ці зміни записуються одразу в обидва місця, що мінімізує можливість отримання застарілих даних.

<ins>Розглянемо приклад використання Write Through для оновлення інформації про користувача в Redis та базі даних за допомогою C#.<ins/>

```
using StackExchange.Redis;
using System;

public class UserService
{
    private IDatabase _cache;
    private IDatabase _database;

    public UserService()
    {
        // Підключення до Redis
        var connection = ConnectionMultiplexer.Connect("localhost");
        _cache = connection.GetDatabase();
        _database = connection.GetDatabase();
    }

    public void UpdateUserProfile(int userId, string newProfileData)
    {
        // Оновлення кешу
        _cache.StringSet($"user:{userId}", newProfileData);
        Console.WriteLine("Data updated in cache.");

        // Оновлення бази даних
        _database.StringSet($"user:{userId}", newProfileData);
        Console.WriteLine("Data updated in database.");
    }
}
```

У цьому прикладі ми оновлюємо профіль користувача одночасно в кеші та базі даних. Під час виклику методу UpdateUserProfile, нові дані спочатку зберігаються в кеші, а потім ці ж дані записуються в основну базу даних, забезпечуючи синхронізацію між ними.

### Переваги

+ Актуальність даних: оскільки кеш завжди синхронізується з базою даних при кожному оновленні, це дозволяє забезпечити актуальність і точність даних у обох місцях.
+ Простота реалізації: підхід Write Through простий у реалізації, оскільки дані завжди одночасно оновлюються в двох місцях, що спрощує логіку управління кешем.
+ Мінімізація ймовірності застарілих даних: оновлення відбувається синхронно, що виключає можливість відображення застарілих даних.

### Недоліки

+ Вища вартість запису: Оскільки кожен запис здійснюється і в кеш, і в базу даних одночасно, це може збільшити час виконання операцій запису і навантаження на систему.
+ Зниження продуктивності при високому навантаженні: Якщо система обробляє велику кількість операцій запису, синхронне оновлення кешу та бази даних може створити затримки та зменшити продуктивність.
+ Ризик блокування: Оскільки кожен запис має бути записаний у дві системи, це може привести до потенційного блокування, особливо в умовах високого навантаження, що знижує загальну ефективність.

Таким чином, патерн Write Through підходить для ситуацій, де важливо мати постійну синхронізацію кешу з базою даних і забезпечити актуальність даних для користувачів, однак його застосування потребує більшої обчислювальної потужності та може знижувати продуктивність при великій кількості операцій запису.

## 3. Write Behind (Write Back)

